Assignment 02: Threads and Scheduling
University of Puerto Rico at Rio Piedras
Department of Computer Science
CCOM4017: Operating Systems
Introduction
In this project the student will simulate a Shortest Job First scheduling algorithm for a distributed system that consists of embedded devices and a central compute server.
The student will assume that we have multiple embedded devices that generate computational problems that are too heavy to be performed in their hardware, either because the device's battery will drain, they do not have enough memory, nor computational resources to perform them in a timely manner.
We will simulate a central server (can be a cluster) that will receive requests for computing time from the embedded devices, will put the jobs in a queue of processes, and then will “execute” them.
Objectives
* Practice threads implementations
* Practice inter process communication using sockets (UDP) and a shared buffer
* Identify critical regions
* Implementation of mutual exclusion and semaphores
REMARK: Your assignment MUST only use the primitive Locks and Semaphores objects. NO other synchronization, or synchronized object library may be used in this assignment. The use of these libraries will immediately invalidate the assignment, and it will not be graded.
Prerequisites
* Python:
   * www.python.org
* Python threads:
   * https://docs.python.org/3/library/threading.html
   * https://pymotw.com/3/threading/ (good tutorial with examples)
* Python sockets (UDP):
   * https://docs.python.org/3/library/socket.html
* Threaded sockets (You are NOT allowed to use this one for this assignment)
   * https://docs.python.org/3/library/socketserver.html
Instructions
The embedded devices:
Each embedded device will consist of one process that will:
1. Concurrently generate random numbers that simulates the time the device “job” will take in the compute server.
2. Send a message for each "job" to the compute server with a device ID.
   * sleep a short (1 to 5 seconds) random period of time between sends.
For instance if the device with ID 3 generates the numbers 3, 5, 2 and so on... the device will send the messages "3:3", "3:5", and "3:2" to the compute server. Note that in this example the syntax is Device ID:job cpu time.
Example of how to run the embedded devices:
#python edevice.py <server address> <server port>

where <server address> is the IP address of the compute server, and <server port> is the port number of the compute server.
Example of how to run the embedded device 2 with server in localhost port 4017:
#python edevice.py 2 localhost 4017


Remark: Your implementation of the edevice MUST be a process. You MUST use big port numbers less than 65,000


The compute server:
The server will consist of two threads:
1. One thread that:
   * listens to the messages generated by the embedded devices and
   * puts the “jobs” in the Shortest Job First Scheduler queue,
2. and another thread to
   * extract the jobs from the queue and “execute” them.
The first thread will act as a producer to the scheduler by:
1. Listen to the embedded devices messages.
2. Take the time and device ID out of the message and store them in a shared queue.
The second thread will act as a consumer by:
1. Picking a message from the shared queue.
2. Keep a table with the sum of times spent in the queue for each device job.
3. Sleep the time extracted from the message picked from the queue.
For instance, lets assume the producer thread receives a message 3:10, the producer puts the message 3:10 in the shared queue. Later the consumer must pick up the message 3:10 from the queue, add to the device 3 counter the time 10, and sleep for 10 seconds.
Your scheduler must stop after the consumer read the Nth (Variable N) time from the queue, and then print the device IDs with the time consumed by its jobs.
Example of how to run the server:
#python scheduler.py <server port>


Note: The consumer must not poll for messages in the shared queue (repeatedly ask for messages in the queue). The thread MUST block until there is a message in the queue.
Example of the scheduler output for 3 embedded devices:
Device 1 consumed 100 seconds of CPU time
Device 2 consumed 132 seconds of CPU time 
Device 3 consumed 204 seconds of CPU time


Other notes
Make every configuration variable a global variable.  Example:
1. Range of sleep times
2. Range of job time
3. Nth message before stopping 
Rubric
1. Documentation of the code and the README (10 pts)
2. Use of an unsynchronized Data Structure for the messages (5 pts) 
   1. Remember that the use of a synchronized data structure will invalidate your project.
3. Implementation of Semaphores for blocking and not polling or busy waiting (10 pts)
4. Implementation of Mutexes to protect the critical regions. (Only the critical regions) (10 pts)
5. Use of the sleep libraries (5 pts)
6. Implementation of UDP sockets for message communication(10 pts)
7. Working implementation of the compute server (30 pts)
8. Working implementation of the embedded devices. (20 pts)
Deliverables
* The source code of the programs (well documented)
* A README file with:
   * Good description of the program
   * How to use your program, how to execute the processes.
   * Any additional reference used to perform the project and the names of students who helped perform the project.
      * Verbal collaborations are allowed, however any form of code sharing is not allowed.
Bonus
Implement the embedded devices (edevice.py) such that it sends the jobs to the compute server and waits for a response of the compute server instead of just randomly sleep to send the next job.
